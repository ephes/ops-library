#!/usr/bin/env python3
"""
Deployment script for apt_upgrade service that outputs JSON steps for fastDeploy
Updated to support secure configuration files from security hardening
"""

import json
import subprocess
import sys
import os
from pathlib import Path
from typing import Dict, Optional

def read_config_file() -> Optional[Dict]:
    """Read deployment configuration from secure file if available."""
    config_file = None
    
    # Check for --config argument
    if "--config" in sys.argv:
        idx = sys.argv.index("--config")
        if idx + 1 < len(sys.argv):
            config_file = sys.argv[idx + 1]
    
    # Also check environment variable as fallback
    if not config_file:
        config_file = os.environ.get("DEPLOY_CONFIG_FILE")
    
    if not config_file or not Path(config_file).exists():
        return None
    
    try:
        with open(config_file, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Warning: Failed to read config file: {e}", file=sys.stderr)
        return None

def output_step(name: str, state: str, message: str = "", error_message: str = "") -> None:
    """Output step as JSON for fastDeploy to parse."""
    step = {
        "name": name,
        "state": state,
        "message": message
    }
    if error_message:
        step["error_message"] = error_message
    
    print(json.dumps(step), flush=True)

def run_ansible_playbook():
    """Run ansible playbook and parse output to create individual task steps."""
    
    service_path = Path("{{ apt_upgrade_service_path }}")
    playbook_path = service_path / "playbook.yml"
    
    # Output initial step
    output_step("bootstrap", "running", "Starting apt upgrade playbook")
    
    # Build ansible command
    cmd = [
        "{{ apt_upgrade_ansible_venv }}/bin/ansible-playbook",
        str(playbook_path),
        "-i", "localhost,",
        "-c", "local",
        "--become",
        "-v"
    ]
    
    # Set environment for ansible
    env = os.environ.copy()
    env["ANSIBLE_HOST_KEY_CHECKING"] = "False"
    
    try:
        # Start the ansible process
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            env=env
        )
        
        output_step("bootstrap", "success", "Ansible playbook started")
        
        current_task = None
        current_play = None
        task_count = 0
        
        # Process output line by line
        for line in process.stdout:
            line = line.strip()
            
            # Detect play start
            if line.startswith("PLAY ["):
                play_name = line[6:-4]  # Extract play name
                if play_name and play_name != "localhost":
                    current_play = play_name
                    output_step(f"play: {play_name}", "running", "Starting play")
            
            # Detect task start
            elif line.startswith("TASK ["):
                # Extract task name from "TASK [task_name] ***"
                task_end = line.find("]")
                if task_end > 6:
                    task_name = line[6:task_end]
                    if task_name != "Gathering Facts":
                        task_count += 1
                        current_task = task_name
                        output_step(task_name, "running", f"Executing task")
            
            # Detect task results
            elif current_task and (line.startswith("ok:") or line.startswith("changed:") or line.startswith("skipping:")):
                if line.startswith("ok:"):
                    output_step(current_task, "success", "Task completed - No changes")
                elif line.startswith("changed:"):
                    output_step(current_task, "success", "Task completed - Changed")
                elif line.startswith("skipping:"):
                    output_step(current_task, "success", "Task skipped")
                current_task = None
            
            # Detect task failure
            elif current_task and line.startswith("fatal:"):
                output_step(current_task, "failure", "", error_message="Task failed")
                current_task = None
            
            # Detect play recap (end of playbook)
            elif line.startswith("PLAY RECAP"):
                if current_play:
                    output_step(f"play: {current_play}", "success", "Play completed")
        
        # Wait for process to complete
        return_code = process.wait()
        
        if return_code == 0:
            output_step("ansible", "success", "Apt upgrade completed successfully")
        else:
            output_step("ansible", "failure", "", error_message=f"Ansible playbook failed with exit code {return_code}")
            
    except Exception as e:
        output_step("ansible", "failure", "", error_message=str(e))
        sys.exit(1)

def main():
    """Main entry point."""
    try:
        # Read config file if available (for compatibility with security hardening)
        config = read_config_file()
        if config:
            # Config file exists, we're running with secure configuration
            # The deployment context and tokens are in the config file
            # But for apt_upgrade, we don't need them as we run ansible locally
            pass
        
        # Change to service directory
        service_path = Path("{{ apt_upgrade_service_path }}")
        os.chdir(service_path)
        
        # Run the ansible playbook
        run_ansible_playbook()
        
    except Exception as e:
        output_step("deployment", "failure", "", error_message=str(e))
        sys.exit(1)

if __name__ == "__main__":
    main()