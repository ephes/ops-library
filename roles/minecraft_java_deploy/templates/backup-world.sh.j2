#!/bin/bash
# Minecraft World Backup Script (Tier 1 - Operational Backups)
# Generated by Ansible - minecraft_java_deploy role
#
# This script creates hourly backups with proper save coordination
# to prevent world corruption during backup.

set -euo pipefail

# Configuration
BACKUP_DIR="{{ minecraft_java_backup_dir }}"
SERVER_DIR="{{ minecraft_java_server_dir }}"
WORLD_NAME="{{ minecraft_java_world_name }}"
RETENTION_MINUTES="{{ minecraft_java_cron_backup_retention_minutes }}"
RCON_HOST="127.0.0.1"
RCON_PORT="{{ minecraft_java_rcon_port }}"
RCON_PASSWORD="{{ minecraft_java_rcon_password }}"

# Timestamp for backup filename
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/${WORLD_NAME}-${TIMESTAMP}.tar.gz"

# Track whether saves are disabled (for cleanup)
SAVES_DISABLED=false

# mcrcon path (cron has minimal PATH, so use absolute path)
MCRCON="/usr/local/bin/mcrcon"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

# CRITICAL: Always re-enable saves on ANY exit (success, failure, or signal)
cleanup() {
    if [[ "$SAVES_DISABLED" == "true" ]]; then
        log "Re-enabling auto-save..."
        "$MCRCON" -H "$RCON_HOST" -P "$RCON_PORT" -p "$RCON_PASSWORD" "save-on" 2>/dev/null || \
            log "WARNING: Failed to re-enable saves! Manual intervention may be required."
    fi
}
trap cleanup EXIT

# Check if server service is running
if ! systemctl is-active --quiet "{{ minecraft_java_service_name }}"; then
    log "Server not running, skipping backup"
    exit 0
fi

log "Starting world backup..."

# Disable auto-save
log "Disabling auto-save..."
"$MCRCON" -H "$RCON_HOST" -P "$RCON_PORT" -p "$RCON_PASSWORD" "save-off" || {
    log "ERROR: Failed to disable auto-save"
    exit 1
}
SAVES_DISABLED=true

# Flush world to disk with timeout
log "Flushing world to disk..."
SAVE_OUTPUT=$(timeout 30 "$MCRCON" -H "$RCON_HOST" -P "$RCON_PORT" -p "$RCON_PASSWORD" "save-all" 2>&1) || {
    log "ERROR: save-all command timed out"
    exit 1
}

# Check for confirmation
if ! echo "$SAVE_OUTPUT" | grep -qi "saved"; then
    log "ERROR: save-all did not confirm. Output: $SAVE_OUTPUT"
    exit 1
fi

log "World saved successfully"

# Wait a moment for disk writes to complete
sleep 2

# Create backup
log "Creating backup archive: $BACKUP_FILE"
cd "$SERVER_DIR"

# Build list of files to backup (world and server.properties are required, others are optional)
BACKUP_FILES=("$WORLD_NAME" "server.properties")
for optional_file in ops.json whitelist.json banned-ips.json banned-players.json; do
    if [[ -f "$optional_file" ]]; then
        BACKUP_FILES+=("$optional_file")
    fi
done
{% if minecraft_java_loader_mode == 'forge' %}
for optional_dir in mods config; do
    if [[ -d "$optional_dir" ]]; then
        BACKUP_FILES+=("$optional_dir")
    fi
done
{% endif %}

tar -czf "$BACKUP_FILE" "${BACKUP_FILES[@]}" || {
    log "ERROR: Failed to create backup archive"
    exit 1
}

# Calculate backup size
BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
log "Backup created: $BACKUP_FILE ($BACKUP_SIZE)"

# Prune old backups (older than retention period)
log "Pruning backups older than $RETENTION_MINUTES minutes..."
PRUNED_COUNT=$(find "$BACKUP_DIR" -name "${WORLD_NAME}-*.tar.gz" -type f -mmin +$RETENTION_MINUTES -delete -print | wc -l)
if [[ "$PRUNED_COUNT" -gt 0 ]]; then
    log "Pruned $PRUNED_COUNT old backup(s)"
fi

# Count remaining backups
BACKUP_COUNT=$(find "$BACKUP_DIR" -name "${WORLD_NAME}-*.tar.gz" -type f | wc -l)
log "Total backups: $BACKUP_COUNT"

log "Backup complete!"
# cleanup trap will re-enable saves
