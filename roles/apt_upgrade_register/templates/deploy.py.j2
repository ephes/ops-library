#!/usr/bin/env python3
"""
Deployment script for apt_upgrade service that outputs JSON steps for FastDeploy
Executes ansible playbook to perform system updates
"""

import json
import subprocess
import sys
import os
from pathlib import Path
from typing import Dict, Optional

def output_step(name: str, state: str, message: str = "", error_message: str = "") -> None:
    """Output step as JSON for FastDeploy to parse."""
    step = {
        "name": name,
        "state": state,
        "message": message
    }
    if error_message:
        step["error_message"] = error_message

    print(json.dumps(step), flush=True)

def run_ansible_playbook():
    """Run ansible playbook and parse output to create individual task steps."""

    service_path = Path("{{ apt_upgrade_service_path }}")
    playbook_path = service_path / "playbook.yml"

    # Output initial step
    output_step("bootstrap", "running", "Starting apt upgrade playbook")

    # Build ansible command using configured ansible path
    cmd = [
        "{{ apt_upgrade_ansible_path }}",
        str(playbook_path)
    ]

    # Add inventory and connection based on target type
    if "{{ apt_upgrade_target_type }}" == "local":
        cmd.extend(["-i", "localhost,", "-c", "local"])
    else:
        # For remote targets, use proper inventory
        cmd.extend(["-i", "{{ apt_upgrade_target }},"])

    cmd.extend(["--become"])

    # Set environment for ansible
    env = os.environ.copy()
    env["ANSIBLE_HOST_KEY_CHECKING"] = "False"

    try:
        # Start the ansible process
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            env=env
        )

        output_step("bootstrap", "success", "Ansible playbook started")

        current_task = None
        task_count = 0

        # Process output line by line
        for line in process.stdout:
            line = line.strip()

            # Skip empty lines
            if not line:
                continue

            # Detect task start
            if line.startswith("TASK ["):
                task_end = line.find("]")
                if task_end > 6:
                    task_name = line[6:task_end]
                    if task_name != "Gathering Facts":
                        task_count += 1
                        current_task = task_name
                        output_step(task_name, "running", "Executing task")

            # Detect task results
            elif current_task and (line.startswith("ok:") or line.startswith("changed:") or line.startswith("skipping:")):
                if line.startswith("ok:"):
                    output_step(current_task, "success", "Task completed - No changes")
                elif line.startswith("changed:"):
                    output_step(current_task, "success", "Task completed - Changed")
                elif line.startswith("skipping:"):
                    output_step(current_task, "success", "Task skipped")
                current_task = None

            # Detect task failure
            elif current_task and line.startswith("fatal:"):
                output_step(current_task, "failure", "", error_message="Task failed")
                current_task = None

        # Wait for process to complete
        return_code = process.wait()

        if return_code == 0:
            output_step("completion", "success", "Apt upgrade completed successfully")
        else:
            output_step("completion", "failure", "", error_message=f"Ansible playbook failed with exit code {return_code}")
            sys.exit(1)

    except Exception as e:
        output_step("execution", "failure", "", error_message=str(e))
        sys.exit(1)

def main():
    """Main entry point."""
    try:
        # Change to service directory
        service_path = Path("{{ apt_upgrade_service_path }}")
        os.chdir(service_path)

        # Run the ansible playbook
        run_ansible_playbook()

    except Exception as e:
        output_step("deployment", "failure", "", error_message=str(e))
        sys.exit(1)

if __name__ == "__main__":
    main()