---
- name: Validate restore inputs
  ansible.builtin.assert:
    that:
      - mastodon_restore_root | length > 0
      - mastodon_restore_archive | length > 0
    fail_msg: "mastodon_restore_root and mastodon_restore_archive are required"

- name: Determine archive when set to latest
  ansible.builtin.find:
    paths: "{{ mastodon_restore_root }}"
    patterns: "*.{{ mastodon_backup_archive_extension }}"
    file_type: file
  register: mastodon_restore_candidates
  when: mastodon_restore_archive == "latest"

- name: Select restore archive
  ansible.builtin.set_fact:
    mastodon_restore_selected_archive: >-
      {{ (mastodon_restore_candidates.files | sort(attribute='mtime', reverse=true) | first).path
         if mastodon_restore_archive == 'latest'
         else (mastodon_restore_archive if mastodon_restore_archive.startswith('/') else mastodon_restore_root ~ '/' ~ mastodon_restore_archive) }}

- name: Fail when no archive is available
  ansible.builtin.fail:
    msg: "No Mastodon backup archives found in {{ mastodon_restore_root }}"
  when:
    - (mastodon_restore_selected_archive | default('')) | length == 0

- name: Ensure selected archive exists
  ansible.builtin.stat:
    path: "{{ mastodon_restore_selected_archive }}"
  register: mastodon_restore_archive_stat

- name: Abort on missing archive
  ansible.builtin.fail:
    msg: "Mastodon restore archive not found: {{ mastodon_restore_selected_archive }}"
  when: not mastodon_restore_archive_stat.stat.exists

- name: Reset staging directory
  ansible.builtin.file:
    path: "{{ mastodon_restore_staging_dir }}"
    state: absent

- name: Create staging directory
  ansible.builtin.file:
    path: "{{ mastodon_restore_staging_dir }}"
    state: directory
    mode: "0700"

- name: Unpack restore archive
  ansible.builtin.unarchive:
    src: "{{ mastodon_restore_selected_archive }}"
    dest: "{{ mastodon_restore_staging_dir }}"
    remote_src: true

- name: Locate extracted payload directory
  ansible.builtin.find:
    paths: "{{ mastodon_restore_staging_dir }}"
    file_type: directory
    depth: 1
  register: mastodon_restore_payload_dirs

- name: Set payload path
  ansible.builtin.set_fact:
    mastodon_restore_payload_dir: "{{ (mastodon_restore_payload_dirs.files | map(attribute='path') | list | first) | default('') }}"

- name: Abort when payload directory missing
  ansible.builtin.fail:
    msg: "Unable to locate payload directory inside restore archive"
  when: mastodon_restore_payload_dir | length == 0

- name: Gather payload content stats
  ansible.builtin.stat:
    path: "{{ item.path }}"
  register: mastodon_restore_payload_stats
  loop:
    - { path: "{{ mastodon_restore_payload_dir }}/database/{{ mastodon_restore_postgres_database }}.dump", label: "database dump" }
    - { path: "{{ mastodon_restore_payload_dir }}/media", label: "media" }
    - { path: "{{ mastodon_restore_payload_dir }}/config/mastodon.env", label: "env" }
    - { path: "{{ mastodon_restore_payload_dir }}/systemd", label: "systemd" }
    - { path: "{{ mastodon_restore_payload_dir }}/traefik/{{ mastodon_traefik_config_path | basename }}", label: "traefik" }
    - { path: "{{ mastodon_restore_payload_dir }}/nginx/{{ mastodon_nginx_config_path | basename }}", label: "nginx" }
  loop_control:
    label: "{{ item.label }}"

- name: Abort when database dump is missing
  ansible.builtin.fail:
    msg: "Database dump missing inside archive"
  when: not mastodon_restore_payload_stats.results[0].stat.exists

- name: Stop Mastodon services before restore
  ansible.builtin.systemd:
    name: "{{ item }}"
    state: stopped
  loop: "{{ mastodon_systemd_services }}"
  failed_when: false
  when: mastodon_restore_stop_services | bool

- name: Ensure media directory exists
  ansible.builtin.file:
    path: "{{ mastodon_media_path }}"
    state: directory
    owner: "{{ mastodon_user }}"
    group: "{{ mastodon_group }}"
    mode: "0750"

- name: Ensure site directory exists
  ansible.builtin.file:
    path: "{{ mastodon_site_path }}"
    state: directory
    owner: "{{ mastodon_user }}"
    group: "{{ mastodon_group }}"
    mode: "0750"

- name: Build restore connection flags
  ansible.builtin.set_fact:
    mastodon_restore_pg_host_flag: "{{ (mastodon_restore_postgres_host | default('') | string | length > 0) | ternary('--host=' ~ mastodon_restore_postgres_host, '') }}"
    mastodon_restore_pg_port_flag: "{{ (mastodon_restore_postgres_port | default('') | string | length > 0) | ternary('--port=' ~ mastodon_restore_postgres_port, '') }}"

- name: Drop Mastodon database
  ansible.builtin.shell: |
    set -euo pipefail
    {{ mastodon_restore_postgres_dropdb_binary }} \
      --if-exists \
      {{ mastodon_restore_postgres_database }}
  args:
    executable: /bin/bash
  become: true
  become_user: "{{ mastodon_restore_postgres_become_user }}"
  environment:
    PGPASSWORD: "{{ mastodon_restore_postgres_password }}"
  no_log: "{{ (mastodon_restore_postgres_password | default('') | length > 0) }}"

- name: Recreate Mastodon database
  ansible.builtin.shell: |
    set -euo pipefail
    {{ mastodon_restore_postgres_createdb_binary }} \
      --owner={{ mastodon_restore_postgres_user }} \
      {{ mastodon_restore_postgres_database }}
  args:
    executable: /bin/bash
  become: true
  become_user: "{{ mastodon_restore_postgres_become_user }}"
  environment:
    PGPASSWORD: "{{ mastodon_restore_postgres_password }}"
  no_log: "{{ (mastodon_restore_postgres_password | default('') | length > 0) }}"

- name: Ensure database dump readable by Postgres user
  ansible.builtin.file:
    path: "{{ mastodon_restore_payload_dir }}/database/{{ mastodon_restore_postgres_database }}.dump"
    owner: "{{ mastodon_restore_postgres_become_user }}"
    group: "{{ mastodon_restore_postgres_become_user }}"
    mode: "0640"

- name: Restore PostgreSQL dump
  ansible.builtin.shell: |
    set -euo pipefail
    {{ mastodon_restore_postgres_restore_binary }} \
      {{ mastodon_restore_pg_host_flag }} \
      {{ mastodon_restore_pg_port_flag }} \
      --username={{ mastodon_restore_postgres_user }} \
      --dbname={{ mastodon_restore_postgres_database }} \
      --clean --if-exists --no-owner \
      "{{ mastodon_restore_payload_dir }}/database/{{ mastodon_restore_postgres_database }}.dump"
  args:
    executable: /bin/bash
  become: true
  become_user: "{{ mastodon_restore_postgres_become_user }}"
  environment:
    PGPASSWORD: "{{ mastodon_restore_postgres_password }}"
  no_log: "{{ (mastodon_restore_postgres_password | default('') | length > 0) }}"

- name: Restore media directory
  ansible.builtin.command:
    cmd: >
      rsync -a --delete "{{ mastodon_restore_payload_dir }}/media/" "{{ mastodon_media_path }}/"
  changed_when: true
  when:
    - mastodon_restore_payload_stats.results[1].stat.exists
    - mastodon_storage_driver == 'local'

- name: Restore environment file
  ansible.builtin.copy:
    src: "{{ mastodon_restore_payload_dir }}/config/mastodon.env"
    dest: "{{ mastodon_env_file }}"
    owner: "{{ mastodon_user }}"
    group: "{{ mastodon_group }}"
    mode: "0600"
    remote_src: true
  when: mastodon_restore_payload_stats.results[2].stat.exists

- name: Restore systemd units when present
  ansible.builtin.find:
    paths: "{{ mastodon_restore_payload_dir }}/systemd"
    file_type: file
    recurse: false
  register: mastodon_restore_systemd_files
  failed_when: false
  when: mastodon_restore_payload_stats.results[3].stat.exists

- name: Copy systemd unit files
  ansible.builtin.copy:
    src: "{{ item.path }}"
    dest: "{{ mastodon_systemd_unit_dir }}/{{ item.path | basename }}"
    owner: root
    group: root
    mode: "0644"
    remote_src: true
  loop: "{{ mastodon_restore_systemd_files.files | default([]) }}"
  register: mastodon_restore_unit_copy
  when: mastodon_restore_payload_stats.results[3].stat.exists

- name: Restore Traefik configuration when present
  ansible.builtin.copy:
    src: "{{ mastodon_restore_payload_dir }}/traefik/{{ mastodon_traefik_config_path | basename }}"
    dest: "{{ mastodon_traefik_config_path }}"
    owner: root
    group: root
    mode: "0644"
    remote_src: true
  when: mastodon_restore_payload_stats.results[4].stat.exists

- name: Restore nginx configuration when present
  ansible.builtin.copy:
    src: "{{ mastodon_restore_payload_dir }}/nginx/{{ mastodon_nginx_config_path | basename }}"
    dest: "{{ mastodon_nginx_config_path }}"
    owner: root
    group: root
    mode: "0644"
    remote_src: true
  when: mastodon_restore_payload_stats.results[5].stat.exists

- name: Reload systemd when unit files changed
  ansible.builtin.systemd:
    daemon_reload: true
  when: mastodon_restore_unit_copy is defined and mastodon_restore_unit_copy.changed

- name: Run migrations after restore
  ansible.builtin.shell: |
    set -euo pipefail
    export RBENV_ROOT="{{ mastodon_rbenv_root }}"
    export PATH="{{ mastodon_rbenv_root }}/bin:{{ mastodon_rbenv_root }}/shims:/usr/local/bin:/usr/bin:/bin"
    set -a
    . "{{ mastodon_env_file }}"
    set +a
    cd "{{ mastodon_site_path }}"
    bundle exec rails db:migrate
  args:
    executable: /bin/bash
  become: true
  become_user: "{{ mastodon_user }}"
  when: mastodon_restore_run_migrations | bool

- name: Start Mastodon services after restore
  ansible.builtin.systemd:
    name: "{{ item }}"
    enabled: true
    state: "{{ mastodon_restore_restart | bool | ternary('restarted', 'started') }}"
    daemon_reload: true
  loop: "{{ mastodon_systemd_services }}"
  failed_when: false

- name: Cleanup restore staging directory
  ansible.builtin.file:
    path: "{{ mastodon_restore_staging_dir }}"
    state: absent
  when: mastodon_restore_cleanup | bool
