#!/usr/bin/env python3
from __future__ import annotations

import json
import os
import re
import subprocess
import sys
from datetime import datetime, timezone
from typing import Any

SMARTCTL_ARGS = ["smartctl", "-H", "-A"]
{% if nyxmon_storage_exporter_smartctl_no_spinup | default(false) | bool %}
SMARTCTL_ARGS += ["-n", "standby"]
{% endif %}

QUIET_HOURS_ENABLED = {{ nyxmon_storage_exporter_quiet_hours_enabled | default(false) | bool | ternary('True', 'False') }}
QUIET_HOURS_START = "{{ nyxmon_storage_exporter_quiet_hours_start | default('06:00') }}"
QUIET_HOURS_END = "{{ nyxmon_storage_exporter_quiet_hours_end | default('22:00') }}"
QUIET_SKIP_POOLS = json.loads(r'''{{ nyxmon_storage_exporter_quiet_hours_skip_pools | default([]) | to_json }}''')
QUIET_SKIP_DISK_TYPES = json.loads(r'''{{ nyxmon_storage_exporter_quiet_hours_skip_disk_types | default(['sat']) | to_json }}''')
QUIET_SPINDOWN_ENABLED = {{ nyxmon_storage_exporter_quiet_hours_spindown_enabled | default(false) | bool | ternary('True', 'False') }}
QUIET_SPINDOWN_SCRIPT = "{{ nyxmon_storage_exporter_quiet_hours_spindown_script | default('') }}"
QUIET_SPINDOWN_MIN_INTERVAL_SEC = {{ nyxmon_storage_exporter_quiet_hours_spindown_min_interval_sec | default(300) | int }}
QUIET_SPINDOWN_STATE_FILE = "{{ nyxmon_storage_exporter_quiet_hours_spindown_state_file | default('/run/nyxmon-storage-metrics-spindown.ts') }}"


def _run(argv: list[str]) -> subprocess.CompletedProcess[str]:
    try:
        return subprocess.run(argv, check=False, capture_output=True, text=True)
    except FileNotFoundError as err:
        # Return a fake CompletedProcess with an error message
        return subprocess.CompletedProcess(
            args=argv,
            returncode=127,
            stdout="",
            stderr=f"command not found: {argv[0] if argv else 'unknown'}",
        )


def _now_ts() -> int:
    return int(datetime.now(tz=timezone.utc).timestamp())


def _parse_zpool_scan_ts(zpool_status_output: str) -> int | None:
    """Parse scrub timestamp from zpool status output.

    zpool outputs timestamps in local time (e.g., 'Sun Dec 14 07:24:50 2025'),
    so we parse without timezone and let mktime() interpret as local time.

    Handles both:
    - Completed scrubs: "scan: scrub repaired 0B in 00:00:01 ... on Sun Dec 14 07:24:50 2025"
    - In-progress scrubs: "scan: scrub in progress since Sun Dec 14 07:24:50 2025"
    """
    import time

    for line in zpool_status_output.splitlines():
        line = line.strip()
        if not line.startswith("scan:"):
            continue
        # Try "on <date>" first (completed scrub), then "since <date>" (in progress)
        match = re.search(r"on (.*)$", line) or re.search(r"since (.*)$", line)
        if not match:
            continue
        raw = match.group(1).strip()
        try:
            # Parse as naive datetime, then convert to timestamp using local timezone
            dt = datetime.strptime(raw, "%a %b %d %H:%M:%S %Y")
            # Use time.mktime to interpret as local time
            return int(time.mktime(dt.timetuple()))
        except ValueError:
            return None
    return None


def _zpool_list(pools: list[str], skip_pools: set[str]) -> dict[str, dict[str, Any]]:
    if not pools:
        if skip_pools:
            return {}
        result = _run(["zpool", "list", "-H", "-o", "name,health,size,alloc,free,cap"])
        if result.returncode != 0:
            return {"_error": {"error": result.stderr.strip() or "zpool list failed"}}
        pools = [line.split()[0] for line in result.stdout.splitlines() if line.split()]

    payload: dict[str, dict[str, Any]] = {}
    for name in pools:
        if name in skip_pools:
            payload[name] = {"skipped": True, "reason": "quiet_hours"}
            continue
        result = _run(["zpool", "list", "-H", "-o", "name,health,size,alloc,free,cap", name])
        if result.returncode != 0:
            payload[name] = {"error": result.stderr.strip() or "zpool list failed"}
            continue
        parts = result.stdout.split()
        if len(parts) != 6:
            payload[name] = {"error": "unexpected zpool list output"}
            continue
        _, health, size, alloc, free, cap = parts
        payload[name] = {
            "health": health,
            "size": size,
            "alloc": alloc,
            "free": free,
            "cap": cap,
        }

        status = _run(["zpool", "status", name])
        if status.returncode == 0:
            scrub_ts = _parse_zpool_scan_ts(status.stdout)
            payload[name]["last_scrub_ts"] = scrub_ts
            payload[name]["last_scrub_age_days"] = (
                None
                if scrub_ts is None
                else round((_now_ts() - scrub_ts) / 86400, 2)
            )
        else:
            payload[name]["status_error"] = status.stderr.strip()

    return payload


def _parse_hhmm(value: str) -> tuple[int, int] | None:
    try:
        parts = value.split(":")
        if len(parts) != 2:
            return None
        hour = int(parts[0])
        minute = int(parts[1])
        if hour < 0 or hour > 23 or minute < 0 or minute > 59:
            return None
        return hour, minute
    except (TypeError, ValueError):
        return None


def _in_quiet_hours() -> bool:
    if not QUIET_HOURS_ENABLED:
        return False
    start = _parse_hhmm(QUIET_HOURS_START)
    end = _parse_hhmm(QUIET_HOURS_END)
    if not start or not end:
        return False
    now = datetime.now().time()
    now_min = now.hour * 60 + now.minute
    start_min = start[0] * 60 + start[1]
    end_min = end[0] * 60 + end[1]
    if start_min == end_min:
        return False
    if start_min < end_min:
        return start_min <= now_min < end_min
    return now_min >= start_min or now_min < end_min


def _read_ts(path: str) -> int | None:
    try:
        with open(path, "r", encoding="utf-8") as f:
            raw = f.read().strip()
        if not raw:
            return None
        return int(raw)
    except (OSError, ValueError):
        return None


def _write_ts(path: str, ts: int) -> bool:
    try:
        parent = os.path.dirname(path)
        if parent:
            os.makedirs(parent, exist_ok=True)
        tmp = f"{path}.tmp"
        with open(tmp, "w", encoding="utf-8") as f:
            f.write(str(ts))
        os.replace(tmp, path)
        return True
    except OSError:
        return False


def _run_quiet_hours_spindown(quiet_active: bool) -> dict[str, Any]:
    status: dict[str, Any] = {"enabled": QUIET_SPINDOWN_ENABLED, "attempted": False}
    if not QUIET_SPINDOWN_ENABLED:
        status["reason"] = "disabled"
        return status
    if not quiet_active:
        status["reason"] = "outside_quiet_hours"
        return status
    if not QUIET_SPINDOWN_SCRIPT:
        status["reason"] = "missing_script"
        return status
    if not os.path.isfile(QUIET_SPINDOWN_SCRIPT):
        status["reason"] = "script_not_found"
        return status
    if not os.access(QUIET_SPINDOWN_SCRIPT, os.X_OK):
        status["reason"] = "script_not_executable"
        return status

    now_ts = _now_ts()
    last_ts = _read_ts(QUIET_SPINDOWN_STATE_FILE)
    status["last_run_ts"] = last_ts
    if last_ts is not None and now_ts - last_ts < QUIET_SPINDOWN_MIN_INTERVAL_SEC:
        status["reason"] = "cooldown"
        status["next_eligible_ts"] = last_ts + QUIET_SPINDOWN_MIN_INTERVAL_SEC
        return status

    result = _run([QUIET_SPINDOWN_SCRIPT])
    status["attempted"] = True
    status["returncode"] = result.returncode
    if result.returncode != 0:
        status["reason"] = "spindown_failed"
        status["error"] = result.stderr.strip() or result.stdout.strip() or "spindown command failed"
        return status

    status["reason"] = "ok"
    status["ok"] = True
    status["run_ts"] = now_ts
    if not _write_ts(QUIET_SPINDOWN_STATE_FILE, now_ts):
        status["state_write_error"] = True
    return status


def _smartctl_health(device: str) -> dict[str, Any]:
    out = _run(SMARTCTL_ARGS + [device])
    payload: dict[str, Any] = {"device": device, "ok": False}
    if out.returncode != 0:
        payload["error"] = out.stderr.strip() or out.stdout.strip() or "smartctl failed"
        return payload

    payload["ok"] = "PASSED" in out.stdout
    temp_match = re.search(
        r"^194\s+Temperature_Celsius\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\d+)",
        out.stdout,
        re.MULTILINE,
    )
    if temp_match:
        payload["temp_c"] = int(temp_match.group(1))
    return payload


def _nvme_smart(device: str) -> dict[str, Any]:
    out = _run(["nvme", "smart-log", "-o", "json", device])
    payload: dict[str, Any] = {"device": device, "ok": False}
    if out.returncode != 0:
        payload["error"] = out.stderr.strip() or out.stdout.strip() or "nvme smart-log failed"
        return payload
    try:
        data = json.loads(out.stdout)
    except json.JSONDecodeError:
        payload["error"] = "nvme smart-log returned non-JSON output"
        return payload

    crit = int(data.get("critical_warning", 0))
    payload["ok"] = crit == 0
    temp_k = data.get("temperature")
    if isinstance(temp_k, (int, float)):
        payload["temp_c"] = round(float(temp_k) - 273.15, 1)
    payload["critical_warning"] = crit
    return payload


def _edac_status() -> dict[str, Any]:
    modules = ""
    try:
        with open("/proc/modules", "r", encoding="utf-8") as f:
            modules = f.read()
    except OSError:
        modules = ""

    edac_loaded = "amd64_edac" in modules or "edac_mce_amd" in modules
    status: dict[str, Any] = {"loaded": edac_loaded, "ce": None, "ue": None}

    base = "/sys/devices/system/edac/mc"
    if not os.path.isdir(base):
        return status

    ce = 0
    ue = 0
    found = False
    for entry in os.listdir(base):
        if not entry.startswith("mc"):
            continue
        found = True
        for counter, total in (("ce_count", "ce"), ("ue_count", "ue")):
            path = os.path.join(base, entry, counter)
            try:
                with open(path, "r", encoding="utf-8") as f:
                    val = int(f.read().strip() or "0")
                if total == "ce":
                    ce += val
                else:
                    ue += val
            except OSError:
                continue

    if found:
        status["ce"] = ce
        status["ue"] = ue
    return status


def main() -> int:
    pools: list[str] = json.loads(r'''{{ nyxmon_storage_exporter_pools | to_json }}''')
    disks: list[dict[str, Any]] = json.loads(r'''{{ nyxmon_storage_exporter_disks | to_json }}''')

    quiet = _in_quiet_hours()
    skip_pools = set(QUIET_SKIP_POOLS) if quiet else set()
    skip_disk_types = set(QUIET_SKIP_DISK_TYPES) if quiet else set()

    payload: dict[str, Any] = {
        "ts": _now_ts(),
        "quiet_hours": {"enabled": QUIET_HOURS_ENABLED, "active": quiet},
    }
    payload["pools"] = _zpool_list(pools, skip_pools)

    disk_results: list[dict[str, Any]] = []
    disks_by_name: dict[str, dict[str, Any]] = {}
    for disk in disks:
        device = disk.get("device")
        dtype = disk.get("type")
        name = disk.get("name")
        if not device:
            continue
        if quiet and dtype in skip_disk_types:
            res = {"device": device, "ok": None, "skipped": True, "reason": "quiet_hours"}
        elif dtype == "nvme":
            res = _nvme_smart(device)
        else:
            res = _smartctl_health(device)
        res["name"] = name
        res["pool"] = disk.get("pool")
        res["type"] = dtype
        disk_results.append(res)
        if name:
            disks_by_name[name] = res
    payload["disks"] = disk_results
    payload["disks_by_name"] = disks_by_name

    payload["quiet_hours"]["spindown"] = _run_quiet_hours_spindown(quiet)
    payload["ecc"] = _edac_status()

    print(json.dumps(payload, sort_keys=True))
    return 0


if __name__ == "__main__":
    sys.exit(main())
