---
- name: Validate restore inputs
  ansible.builtin.assert:
    that:
      - jellyfin_restore_root | length > 0
      - jellyfin_restore_archive | length > 0
    fail_msg: "jellyfin_restore_root and jellyfin_restore_archive are required"

- name: Determine Jellyfin archive when set to latest
  ansible.builtin.find:
    paths: "{{ jellyfin_restore_root }}"
    patterns: "*.{{ jellyfin_backup_archive_extension }}"
    file_type: file
  register: jellyfin_restore_candidates
  when: jellyfin_restore_archive == "latest"

- name: Select Jellyfin archive
  ansible.builtin.set_fact:
    jellyfin_restore_selected_archive: >-
      {{ (jellyfin_restore_candidates.files | sort(attribute='mtime', reverse=true) | first).path
         if jellyfin_restore_archive == "latest"
         else (jellyfin_restore_archive if jellyfin_restore_archive.startswith('/') else jellyfin_restore_root ~ '/' ~ jellyfin_restore_archive) }}

- name: Fail when no archive is available
  ansible.builtin.fail:
    msg: "No Jellyfin backup archives found in {{ jellyfin_restore_root }}"
  when:
    - (jellyfin_restore_selected_archive | default('')) | length == 0

- name: Ensure archive exists
  ansible.builtin.stat:
    path: "{{ jellyfin_restore_selected_archive }}"
  register: jellyfin_restore_selected_stat

- name: Abort on missing archive
  ansible.builtin.fail:
    msg: "Jellyfin restore archive not found: {{ jellyfin_restore_selected_archive }}"
  when: not jellyfin_restore_selected_stat.stat.exists

- name: Reset staging directory
  ansible.builtin.file:
    path: "{{ jellyfin_restore_staging_dir }}"
    state: absent

- name: Create staging directory
  ansible.builtin.file:
    path: "{{ jellyfin_restore_staging_dir }}"
    state: directory
    mode: "0700"

- name: Unpack Jellyfin archive into staging
  ansible.builtin.unarchive:
    src: "{{ jellyfin_restore_selected_archive }}"
    dest: "{{ jellyfin_restore_staging_dir }}"
    remote_src: true

- name: Locate extracted payload directory
  ansible.builtin.find:
    paths: "{{ jellyfin_restore_staging_dir }}"
    file_type: directory
    depth: 1
  register: jellyfin_restore_payload_dirs

- name: Set Jellyfin payload path
  ansible.builtin.set_fact:
    jellyfin_restore_payload_dir: "{{ (jellyfin_restore_payload_dirs.files | map(attribute='path') | list | first) | default('') }}"

- name: Abort when payload directory missing
  ansible.builtin.fail:
    msg: "Unable to locate payload directory inside restore archive"
  when: jellyfin_restore_payload_dir | length == 0

- name: Gather payload content facts
  ansible.builtin.stat:
    path: "{{ item.path }}"
  register: jellyfin_restore_payload_stats
  loop:
    - { path: "{{ jellyfin_restore_payload_dir }}/data", label: "data" }
    - { path: "{{ jellyfin_restore_payload_dir }}/config", label: "config" }
    - { path: "{{ jellyfin_restore_payload_dir }}/systemd/{{ jellyfin_service_unit | basename }}", label: "systemd unit" }
    - { path: "{{ jellyfin_restore_payload_dir }}/traefik/{{ jellyfin_traefik_config_path | basename }}", label: "traefik config" }
    - { path: "{{ jellyfin_restore_payload_dir }}/logs", label: "logs" }
  loop_control:
    label: "{{ item.label }}"

- name: Abort when Jellyfin data payload is missing
  ansible.builtin.fail:
    msg: "Jellyfin data directory missing inside archive: {{ jellyfin_restore_payload_dir }}/data"
  when: not jellyfin_restore_payload_stats.results[0].stat.exists

- name: Ensure Jellyfin directories exist
  ansible.builtin.file:
    path: "{{ item.path }}"
    state: directory
    owner: "{{ item.owner }}"
    group: "{{ item.group }}"
    mode: "{{ item.mode }}"
  loop:
    - { path: "{{ jellyfin_data_dir }}", owner: "{{ jellyfin_user }}", group: "{{ jellyfin_group }}", mode: "0750" }
    - { path: "{{ jellyfin_log_dir }}", owner: "{{ jellyfin_user }}", group: "{{ jellyfin_group }}", mode: "0750" }
    - { path: "{{ jellyfin_config_dir }}", owner: "{{ jellyfin_user }}", group: "{{ jellyfin_group }}", mode: "0750" }
    - { path: "{{ jellyfin_traefik_config_path | dirname }}", owner: "root", group: "root", mode: "0755" }

- name: Stop Jellyfin before restore
  ansible.builtin.systemd:
    name: "{{ jellyfin_service_name }}"
    state: stopped
  failed_when: false
  when: jellyfin_restore_stop_service | bool

- name: Restore Jellyfin data directory
  ansible.builtin.command:
    cmd: >
      rsync -a --delete "{{ jellyfin_restore_payload_dir }}/data/" "{{ jellyfin_data_dir }}/"
  changed_when: true

- name: Restore Jellyfin config directory
  ansible.builtin.command:
    cmd: >
      rsync -a --delete "{{ jellyfin_restore_payload_dir }}/config/" "{{ jellyfin_config_dir }}/"
  changed_when: true
  when: jellyfin_restore_payload_stats.results[1].stat.exists

- name: Restore Jellyfin systemd unit when present
  ansible.builtin.copy:
    src: "{{ jellyfin_restore_payload_dir }}/systemd/{{ jellyfin_service_unit | basename }}"
    dest: "{{ jellyfin_service_unit }}"
    owner: root
    group: root
    mode: "0644"
    remote_src: true
  register: jellyfin_restore_unit_copy
  when: jellyfin_restore_payload_stats.results[2].stat.exists

- name: Restore Traefik configuration when present
  ansible.builtin.copy:
    src: "{{ jellyfin_restore_payload_dir }}/traefik/{{ jellyfin_traefik_config_path | basename }}"
    dest: "{{ jellyfin_traefik_config_path }}"
    owner: root
    group: root
    mode: "0644"
    remote_src: true
  register: jellyfin_restore_traefik_copy
  when: jellyfin_restore_payload_stats.results[3].stat.exists

- name: Restore Jellyfin logs when present
  ansible.builtin.command:
    cmd: >
      rsync -a "{{ jellyfin_restore_payload_dir }}/logs/" "{{ jellyfin_log_dir }}/"
  changed_when: true
  when: jellyfin_restore_payload_stats.results[4].stat.exists

- name: Reload systemd if unit changed
  ansible.builtin.systemd:
    daemon_reload: true
  when: jellyfin_restore_unit_copy is defined and jellyfin_restore_unit_copy.changed

- name: Ensure Jellyfin permissions on data directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ jellyfin_user }}"
    group: "{{ jellyfin_group }}"
    recurse: true
  loop:
    - "{{ jellyfin_data_dir }}"
    - "{{ jellyfin_log_dir }}"
    - "{{ jellyfin_config_dir }}"

- name: Start Jellyfin service after restore
  ansible.builtin.systemd:
    name: "{{ jellyfin_service_name }}"
    enabled: true
    state: "{{ jellyfin_restore_restart | bool | ternary('restarted', 'started') }}"
    daemon_reload: true

- name: Reload Traefik when configuration changed
  ansible.builtin.service:
    name: traefik
    state: reloaded
  failed_when: false
  register: jellyfin_restore_traefik_reload
  when: jellyfin_restore_traefik_copy is defined and jellyfin_restore_traefik_copy.changed

- name: Restart Traefik when reload is not supported
  ansible.builtin.service:
    name: traefik
    state: restarted
  when:
    - jellyfin_restore_traefik_copy is defined and jellyfin_restore_traefik_copy.changed
    - jellyfin_restore_traefik_reload.rc is defined
    - jellyfin_restore_traefik_reload.rc != 0

- name: Cleanup Jellyfin restore staging directory
  ansible.builtin.file:
    path: "{{ jellyfin_restore_staging_dir }}"
    state: absent
  when: jellyfin_restore_cleanup | bool
