#!/usr/bin/env python3
"""
FastDeploy runner for {{ fd_service_name }}
Deployed by Ansible from ops-control
Hybrid approach: NDJSON to stdout (primary) + HTTP API (best-effort)
"""
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Dict, Optional
from urllib.request import Request, urlopen
from urllib.error import URLError

# Ensure unbuffered output for real-time UI updates
os.environ['PYTHONUNBUFFERED'] = '1'


def read_config_file() -> Optional[Dict]:
    """Read deployment configuration from secure file if available."""
    # Check for config file path in environment or command line
    config_file = os.environ.get("DEPLOY_CONFIG_FILE")
    
    # Also check command line arguments for --config
    if "--config" in sys.argv:
        idx = sys.argv.index("--config")
        if idx + 1 < len(sys.argv):
            config_file = sys.argv[idx + 1]
    
    if not config_file or not Path(config_file).exists():
        return None
    
    try:
        with open(config_file, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Failed to read config file: {e}", file=sys.stderr)
        return None


# STDOUT JSON helpers (primary communication channel)
def _emit(obj: Dict) -> None:
    """Emit JSON object to stdout for FastDeploy to parse."""
    print(json.dumps(obj, ensure_ascii=False), flush=True)


def output_step(name: str, state: str, message: str = None) -> None:
    """Output step as NDJSON to stdout (primary channel)."""
    step = {
        "name": name,
        "state": state
    }
    if message:
        step["message"] = message
    _emit(step)


def finish_stdout(status: str, message: str = None) -> None:
    """Output finish event to stdout."""
    finish = {
        "event": "finish",
        "status": status
    }
    if message:
        finish["message"] = message
    _emit(finish)


# HTTP API helpers (best-effort secondary channel)
def post_json(url: str, token: str, payload: Dict) -> bool:
    """Post JSON data to fastDeploy API (best-effort, never blocks)."""
    try:
        data = json.dumps(payload).encode("utf-8")
        req = Request(url, data=data, headers={
            "Content-Type": "application/json",
            "Authorization": f"Bearer {token}",
        })
        with urlopen(req, timeout=5) as response:
            return response.status == 200
    except (URLError, Exception) as e:
        # Log to stderr but never fail the deployment
        print(f"[HTTP API] Failed to post to {url}: {e}", file=sys.stderr)
        return False


def update_step(name: str, state: str, message: str = "") -> None:
    """
    Hybrid step update:
    1. Primary: Output NDJSON to stdout
    2. Secondary: Best-effort HTTP API call
    """
    # Primary channel: stdout NDJSON (always works)
    output_step(name, state, message)
    
    # Secondary channel: HTTP API (best-effort)
    config = read_config_file()
    if config:
        token = config.get("access_token", "")
        steps_url = config.get("steps_url", "")
    else:
        token = os.environ.get("ACCESS_TOKEN", "")
        steps_url = os.environ.get("STEPS_URL", "")
    
    if token and steps_url:
        # Best-effort HTTP call, never blocks or fails deployment
        try:
            post_json(steps_url, token, {
                "name": name,
                "state": state,
                "message": message
            })
        except Exception as e:
            print(f"[HTTP API] Step update failed: {e}", file=sys.stderr)


def finish_deployment(status: str = "success", message: str = None) -> None:
    """
    Hybrid deployment finish:
    1. Primary: Output finish event to stdout
    2. Secondary: Best-effort HTTP API call
    """
    # Primary channel: stdout NDJSON
    finish_stdout(status, message or f"Deployment {status}")
    
    # Secondary channel: HTTP API (best-effort)
    config = read_config_file()
    if config:
        token = config.get("access_token", "")
        finish_url = config.get("deployment_finish_url", "")
    else:
        token = os.environ.get("ACCESS_TOKEN", "")
        finish_url = os.environ.get("DEPLOYMENT_FINISH_URL", "")
    
    if token and finish_url:
        try:
            post_json(finish_url, token, {
                "status": status,
                "message": message
            })
        except Exception as e:
            print(f"[HTTP API] Finish call failed: {e}", file=sys.stderr)


def run_command(cmd: list, cwd: Optional[Path] = None, env: Optional[dict] = None) -> int:
    """Run a command and return exit code."""
    # Log command to stderr to keep stdout clean for NDJSON
    print(f"Running: {' '.join(cmd)}", file=sys.stderr)
    result = subprocess.run(
        cmd,
        cwd=str(cwd) if cwd else None,
        env=env,
        capture_output=False,
        text=True
    )
    return result.returncode


def main() -> int:
    """Main deployment logic."""
    # Emit early init step to anchor UI
    update_step("init", "running", "Starting deployment")
    
    # Try to read from secure config file first
    config = read_config_file()
    
    if config:
        # Use configuration from secure file
        context = config.get("context", {})
        ssh_auth_sock = config.get("ssh_auth_sock")
        if ssh_auth_sock:
            os.environ["SSH_AUTH_SOCK"] = ssh_auth_sock
    else:
        # Fallback to environment variables
        context_raw = os.environ.get("CONTEXT", "{}")
        try:
            context = json.loads(context_raw)
        except json.JSONDecodeError:
            context = {}
    
    update_step("init", "success", "Configuration loaded")
    
    # Get configuration from context or defaults
    cenv = context.get("env", {})
    
    # Use Jinja2 template variables as defaults
    OPS_CONTROL_METHOD = cenv.get("OPS_CONTROL_METHOD", "{{ fd_ops_control_method }}")
    OPS_CONTROL_GIT = cenv.get("OPS_CONTROL_GIT", "{{ fd_ops_control_git | default('') }}")
    OPS_CONTROL_REF = cenv.get("OPS_CONTROL_REF", "{{ fd_ops_control_ref }}")
    FILTER = cenv.get("FILTER", "{{ fd_service_name }}")
    LIMIT = cenv.get("LIMIT", "{{ fd_context_defaults.LIMIT | default('localhost') }}")
    ANSIBLE_PLAYBOOK = cenv.get("ANSIBLE_PLAYBOOK", "{{ fd_ansible_playbook_bin }}")
    ANSIBLE_GALAXY = cenv.get("ANSIBLE_GALAXY", "{{ fd_ansible_galaxy_bin }}")
    SOPS_AGE_KEY_FILE = cenv.get("SOPS_AGE_KEY_FILE", "{{ fd_sops_age_key_path }}")
    ANSIBLE_CONFIG = cenv.get("ANSIBLE_CONFIG", "{{ fd_ansible_config }}")
    
    # Paths
    deploy_home = Path("{{ fd_deploy_home }}")
    ops_control_dir = Path("{{ fd_ops_control_remote_path }}")
    
    # Step 1: Prepare
    update_step("prepare", "running", "Preparing ops-control")
    
    if OPS_CONTROL_METHOD == "rsync":
        # Using rsync method - ops-control is already deployed
        if not ops_control_dir.exists():
            update_step("prepare", "failure", f"ops-control not found at {ops_control_dir}")
            finish_deployment("failure", f"ops-control not found at {ops_control_dir}")
            return 1
        workspace = ops_control_dir
        update_step("prepare", "success", "Using pre-deployed ops-control")
    
    elif OPS_CONTROL_METHOD == "git":
        # Git method - clone/update from repository
        workspace = Path("{{ fd_workspace_dir }}") / "ops-control"
        workspace.parent.mkdir(parents=True, exist_ok=True)
        
        if workspace.exists():
            # Update existing clone
            rc = run_command(["git", "fetch", "--all", "--prune"], cwd=workspace)
            if rc != 0:
                update_step("prepare", "failure", "Failed to fetch updates")
                finish_deployment("failure", "Failed to fetch git updates")
                return 1
            
            run_command(["git", "checkout", OPS_CONTROL_REF], cwd=workspace)
            run_command(["git", "reset", "--hard", f"origin/{OPS_CONTROL_REF}"], cwd=workspace)
        else:
            # Fresh clone
            if not OPS_CONTROL_GIT:
                update_step("prepare", "failure", "OPS_CONTROL_GIT not configured for git method")
                finish_deployment("failure", "OPS_CONTROL_GIT not configured")
                return 1
                
            rc = run_command([
                "git", "clone",
                "--branch", OPS_CONTROL_REF,
                "--single-branch",
                OPS_CONTROL_GIT,
                str(workspace)
            ])
            if rc != 0:
                update_step("prepare", "failure", "Failed to clone repository")
                finish_deployment("failure", "Failed to clone repository")
                return 1
        
        update_step("prepare", "success", "Repository ready")
    
    else:
        update_step("prepare", "failure", f"Unknown OPS_CONTROL_METHOD: {OPS_CONTROL_METHOD}")
        finish_deployment("failure", f"Unknown OPS_CONTROL_METHOD: {OPS_CONTROL_METHOD}")
        return 1
    
    # Step 2: Bootstrap - Install Ansible collections
    update_step("bootstrap", "running", "Installing Ansible collections")
    
    requirements_file = workspace / "collections" / "requirements.yml"
    if requirements_file.exists():
        rc = run_command([
            ANSIBLE_GALAXY, "collection", "install",
            "-r", str(requirements_file),
            "-p", str(workspace / "collections")
        ])
        if rc != 0:
            update_step("bootstrap", "failure", "Failed to install collections")
            finish_deployment("failure", "Failed to install Ansible collections")
            return 1
    
    update_step("bootstrap", "success", "Collections installed")
    
    # Step 3: Ansible - Run the deployment with detailed task reporting
    update_step("ansible", "running", f"Starting deployment of {FILTER}")
    
    # Prepare environment
    env = os.environ.copy()
    env["SOPS_AGE_KEY_FILE"] = SOPS_AGE_KEY_FILE
    env["ANSIBLE_CONFIG"] = ANSIBLE_CONFIG
    
    # Build ansible-playbook command with verbose output for parsing
    cmd = [
        ANSIBLE_PLAYBOOK,
        "-i", str(workspace / "inventories" / "prod" / "hosts.yml"),
        str(workspace / "playbooks" / "site.yml"),
        "-l", LIMIT,
        "--extra-vars", f"filter={FILTER}",
        "--extra-vars", "ansible_connection=local",
        "--become",
        "--become-user", "root",
        "-v"  # Verbose output for better task visibility
    ]
    
    # Run ansible with output parsing
    try:
        process = subprocess.Popen(
            cmd,
            env=env,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1
        )
        
        current_task = None
        current_play = None
        task_count = 0
        
        # Process output line by line for real-time step updates
        for line in process.stdout:
            line = line.strip()
            # Log to stderr for debugging
            print(line, file=sys.stderr)
            
            # Detect play start
            if line.startswith("PLAY ["):
                play_name = line[6:line.find("]")]
                if play_name and play_name != "localhost":
                    current_play = play_name
                    update_step(f"play: {play_name}", "running", "Starting play")
            
            # Detect task start
            elif line.startswith("TASK ["):
                task_end = line.find("]")
                if task_end > 6:
                    task_name = line[6:task_end]
                    # Filter out some common uninteresting tasks
                    if task_name not in ["Gathering Facts", "Filter services for this host", "Display deployment plan"]:
                        task_count += 1
                        current_task = task_name
                        # Make task names more readable
                        if "git" in task_name.lower():
                            update_step(task_name, "running", "Pulling latest code from repository")
                        elif "install" in task_name.lower() or "sync" in task_name.lower():
                            update_step(task_name, "running", "Installing/updating dependencies")
                        elif "restart" in task_name.lower():
                            update_step(task_name, "running", "Restarting service")
                        elif "migrate" in task_name.lower():
                            update_step(task_name, "running", "Running database migrations")
                        else:
                            update_step(task_name, "running", "Executing task")
            
            # Detect task results
            elif current_task and (line.startswith("ok:") or line.startswith("changed:") or line.startswith("skipping:")):
                if line.startswith("ok:"):
                    update_step(current_task, "success", "No changes needed")
                elif line.startswith("changed:"):
                    update_step(current_task, "success", "Changes applied")
                elif line.startswith("skipping:"):
                    update_step(current_task, "success", "Skipped (condition not met)")
                current_task = None
            
            # Detect task failure
            elif current_task and line.startswith("fatal:"):
                update_step(current_task, "failure", "Task failed")
                current_task = None
        
        # Wait for process to complete
        rc = process.wait()
        
        if rc != 0:
            update_step("ansible", "failure", f"Ansible playbook failed with exit code {rc}")
            finish_deployment("failure", f"Ansible playbook failed with exit code {rc}")
            return 1
        
        update_step("ansible", "success", f"Deployment completed - {task_count} tasks executed")
        
    except Exception as e:
        update_step("ansible", "failure", f"Failed to run ansible: {str(e)}")
        finish_deployment("failure", f"Ansible execution error: {str(e)}")
        return 1
    
    # Step 4: Verify - Check service status
    update_step("verify", "running", "Checking service status")
    
    # Check if the service is running (adjust service name as needed)
    service_name = "{{ fd_service_name }}.service"
    rc = run_command(["systemctl", "is-active", "--quiet", service_name])
    
    if rc == 0:
        update_step("verify", "success", f"{service_name} is active")
    else:
        update_step("verify", "warning", f"{service_name} is not active (might be expected)")
    
    # Mark deployment as finished successfully
    finish_deployment("success", f"Deployment of {{ fd_service_name }} completed successfully")
    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception as e:
        print(f"Deployment failed with error: {e}", file=sys.stderr)
        update_step("error", "failure", str(e))
        finish_deployment("failure", f"Unexpected error: {e}")
        sys.exit(1)