---
- name: Validate inputs
  ansible.builtin.assert:
    that:
      - tailscale_restore_root | length > 0
      - tailscale_restore_archive | length > 0
      - tailscale_manual_up | bool or (tailscale_auth_key | length > 0)
      - tailscale_backup_archive_format == "gz"
    fail_msg: "tailscale_restore_* variables invalid or missing auth key (required unless manual_up=true)"

- name: Determine archive to restore (latest shortcut)
  ansible.builtin.find:
    paths: "{{ tailscale_restore_root }}"
    patterns: "*.{{ tailscale_backup_archive_extension }}"
    file_type: file
  register: tailscale_restore_candidates
  when: tailscale_restore_archive == "latest"

- name: Select latest archive
  ansible.builtin.set_fact:
    tailscale_restore_selected_archive: "{{ (tailscale_restore_candidates.files | sort(attribute='mtime', reverse=true) | first).path | default('') }}"
  when: tailscale_restore_archive == "latest"

- name: Use explicit archive path
  ansible.builtin.set_fact:
    tailscale_restore_selected_archive: "{{ tailscale_restore_archive if tailscale_restore_archive.startswith('/') else tailscale_restore_root ~ '/' ~ tailscale_restore_archive }}"
  when: tailscale_restore_archive != "latest"

- name: Abort when archive path is empty
  ansible.builtin.fail:
    msg: "No Tailscale backup archives found in {{ tailscale_restore_root }}"
  when: tailscale_restore_selected_archive | length == 0

- name: Ensure archive exists
  ansible.builtin.stat:
    path: "{{ tailscale_restore_selected_archive }}"
  register: tailscale_restore_selected_stat

- name: Abort when archive is missing
  ansible.builtin.fail:
    msg: "Tailscale restore archive not found: {{ tailscale_restore_selected_archive }}"
  when: not tailscale_restore_selected_stat.stat.exists

- name: Record archive basename
  ansible.builtin.set_fact:
    tailscale_restore_selected_basename: "{{ tailscale_restore_selected_archive | basename }}"

- name: Guard against restoring the wrong host's archive
  ansible.builtin.assert:
    that:
      - tailscale_restore_selected_basename.startswith(inventory_hostname ~ '-')
    fail_msg: "Archive {{ tailscale_restore_selected_basename }} does not match host {{ inventory_hostname }} (prefix check failed)"

- name: Verify archive integrity before extraction
  ansible.builtin.command:
    cmd: tar -tzf "{{ tailscale_restore_selected_archive }}"
  changed_when: false

- name: Reset staging directory
  ansible.builtin.file:
    path: "{{ tailscale_restore_staging_dir }}"
    state: absent

- name: Create staging directory
  ansible.builtin.file:
    path: "{{ tailscale_restore_staging_dir }}"
    state: directory
    mode: "0700"

- name: Unpack archive into staging
  ansible.builtin.unarchive:
    src: "{{ tailscale_restore_selected_archive }}"
    dest: "{{ tailscale_restore_staging_dir }}"
    remote_src: true

- name: Locate extracted payload directory
  ansible.builtin.find:
    paths: "{{ tailscale_restore_staging_dir }}"
    file_type: directory
    depth: 1
  register: tailscale_restore_payload_dirs

- name: Set payload path
  ansible.builtin.set_fact:
    tailscale_restore_payload_dir: "{{ (tailscale_restore_payload_dirs.files | map(attribute='path') | list | first) | default('') }}"

- name: Fail when payload directory missing
  ansible.builtin.fail:
    msg: "Unable to determine payload directory inside restore archive"
  when: tailscale_restore_payload_dir | length == 0

- name: Restore state directory
  ansible.builtin.command:
    cmd: >
      rsync -a "{{ tailscale_restore_payload_dir }}/state/" "{{ tailscale_state_dir }}/"
  changed_when: true

- name: Check for restored sysconfig
  ansible.builtin.stat:
    path: "{{ tailscale_restore_payload_dir }}/config/{{ tailscale_sysconfig_path | basename }}"
  register: tailscale_restore_sysconfig_stat

- name: Check for restored systemd drop-ins
  ansible.builtin.stat:
    path: "{{ tailscale_restore_payload_dir }}/systemd"
  register: tailscale_restore_dropins_stat

- name: Restore sysconfig when present
  ansible.builtin.copy:
    src: "{{ tailscale_restore_payload_dir }}/config/{{ tailscale_sysconfig_path | basename }}"
    dest: "{{ tailscale_sysconfig_path }}"
    owner: root
    group: root
    mode: "0644"
    remote_src: true
  when: tailscale_restore_sysconfig_stat.stat.exists | default(false)

- name: Restore systemd drop-ins when present
  ansible.builtin.command:
    cmd: >
      rsync -a "{{ tailscale_restore_payload_dir }}/systemd/" "{{ tailscale_systemd_dropin_dir }}/"
  when:
    - tailscale_backup_include_dropins | bool
    - tailscale_restore_dropins_stat.stat.exists | default(false)
  changed_when: true

- name: Reload systemd after restoring drop-ins
  ansible.builtin.systemd:
    daemon_reload: true
  when:
    - tailscale_backup_include_dropins | bool
    - tailscale_restore_dropins_stat.stat.exists | default(false)

- name: Ensure tailscaled service state after restore
  ansible.builtin.systemd:
    name: "{{ tailscale_service_name }}"
    enabled: true
    state: "{{ tailscale_restore_restart_service | bool | ternary('restarted', 'started') }}"

- name: Re-run tailscale up after restore (optional)
  ansible.builtin.command:
    cmd: >
      {{ tailscale_bin }} up
      --hostname={{ tailscale_hostname }}
      --accept-routes={{ tailscale_accept_routes | ternary('true','false') }}
      --accept-dns={{ tailscale_accept_dns | ternary('true','false') }}
      {% if tailscale_exit_node | length > 0 %}--exit-node={{ tailscale_exit_node }}{% endif %}
      {% if tailscale_advertise_exit_node | bool %}--advertise-exit-node{% endif %}
      {{ tailscale_args_extra }}
      --authkey={{ tailscale_auth_key }}
  when:
    - tailscale_restore_force_reup | bool
    - not tailscale_manual_up | bool
  changed_when: true

- name: Cleanup staging directory
  ansible.builtin.file:
    path: "{{ tailscale_restore_staging_dir }}"
    state: absent
  when: tailscale_restore_cleanup | bool
